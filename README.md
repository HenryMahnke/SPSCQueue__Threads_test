During today's worktime I was working on modernizing the threads software stack for our real time robot code for the CDPR.

In the past we had used the default timer that was specified from the SOEM standard from their example code which was pretty BAD:thumbsdown:. This is because it uses an ancient windows API called TimeSetEvent, which runs in larger part through the windows multimediatimer api. From what I understand this is an OS process that runs the function that you specify every <amount> of time you specify. It can only did it with so much accuracy. I'm also not sure of the exact implementation, it could be scheduling across multiple cores(leading to overhead), it might not heavily prioritize the task(meaning your wifi, or screen refresh processes might overtake the execution of your thread). In addition, it's NOT the way you are supposed to write  modern threaded code, and it is not multi platform compatible (against our wishes to migrate to linux in the future for a real time operating system kernal patch). So today I implemented a test repository that addresses the two largest issues with our current robot code, the speed and use of this old api, as well as proper, state management across threads that share memory. Here is what I did:

Spawn my own real time thread from the main thread to do some "test work". We first make our main processes a real time critical process to the OS to prevent AS MUCH AS POSSIBLE in a non real time operating system the interruptions that may happen. The OS should try to outsource these tasks to other cores if possible. Then, in the creation of the thread we can now initialize a bunch of scoped variables, as the function setup is within our control now, so no more juggling global states that muddy the codebase. This allows us to do 2 more important things. 1. Set thread affinity, this means this thread will try to get pinned to exactly one CPU core. Then, setting the thread priority, so on this single core we can set the thread to the MAXIMUM priority, meaning that the operating system should not try to schedule anything else whatsoever if at all possible. (there are still a few things that are vital to the OS, such that if it feels like it (because it's stupid) will stop your process to run something else (like wifi stuff, refreshing screen etc, you physically cannot get around this on a non rt operating system)).

In addition we initialize our single producer single consumer queue in the main thread. This is the mailman that will send data between the main and real time threads, allowing, in the future, the robot to change states, i.e go from homing -> teleop->auto-> teleop -> done or change which trajectory the user selected, or a whole host of other things! Using that, we can now store the state as a local variable within the thread function, and update it only when we receive new data from the parent/main thread while in our forever loop that actually runs in real time. this prevents blocking calls, and removes the need for global variables to manage state. 

In the code you will see that all we do now is add logging statistics which look like the following:
main thread is sleeping for 20 s
main thread woke up and is sending stop signal to real time thread
Average loop duration: 2000 microseconds
Total running error: 5019 microseconds
Average/Amortized running error: 501 nanoseconds
Worst case jitter: 1949 microseconds
Occurred at cycle: 9044
real time thread has exited
count is 10001
As you can see, over the course of 20s, the main thread could be doing work -> talking to the user and getting keyboard inputs, parsing trajectories for the robot to run in real time in the future. instead we just choose to sleep for 20 seconds. Once the main thread wakes up, we send the stop signal over the SCSP that updates it's state from the previous time we sent an update that said to start running, now we say shut down. The finally we join() the real time thread from the main thread, which is a blocking call that waits for the real time thread to do any last cleanup (the last loop of the forever loop that just ended, and any subsequent cleanup). This is fine because once you finish in your real time thread, your main thread will have no further responsibilities other than ensuring cleanup.

Quirks with this build:
Often times you like to run in DEBUG mode to test different things, get helpful errors etc. We can't actually do that when we set priorities for threads to be this important. Why? As of now, this thread is MORE IMPORTANT than the debugger itself! Meaning the debugger won't be able to read and display the state because you're moving too fast to see it in a sense. You actually just get an abort error!

Overall we showed that in general any given cycle will have minimal jitter (though in the worst case you can fall an entire cycle behind.. EEEK!!!) This also has the interesting consequence that your scheduler runs pseudo-deterministically (every 2 ms from the last cycle) This could mean that you may have to "dig yourself out" of this jitter if you fall too far behind, but it's in fact hard to tell from the implementation WHERE the jitter happens, so I'm not exactly sure of this statement. 

Dependencies used: rigtorp::SPSC (super fast non blocking, fixed size single producer single consumer, header only and templated for custom data types:money_mouth_face:) 
